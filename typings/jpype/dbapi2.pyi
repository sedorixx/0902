"""
This type stub file was generated by pyright.
"""

__all__ = ['ARRAY', 'ASCII_STREAM', 'BIGINT', 'BINARY', 'BINARY_STREAM', 'BIT', 'BLOB', 'BOOLEAN', 'Binary', 'CHAR', 'CHARACTER_STREAM', 'CLOB', 'Connection', 'Cursor', 'DATE', 'DATETIME', 'DECIMAL', 'DOUBLE', 'DataError', 'DatabaseError', 'Date', 'DateFromTicks', 'Error', 'FLOAT', 'GETTERS_BY_NAME', 'GETTERS_BY_TYPE', 'INTEGER', 'IntegrityError', 'InterfaceError', 'InternalError', 'JDBCType', 'LONGNVARCHAR', 'LONGVARBINARY', 'LONGVARCHAR', 'NCHAR', 'NCHARACTER_STREAM', 'NCLOB', 'NULL', 'NUMBER', 'NUMERIC', 'NVARCHAR', 'NotSupportedError', 'OBJECT', 'OTHER', 'OperationalError', 'ProgrammingError', 'REAL', 'REF', 'RESULTSET', 'ROWID', 'SETTERS_BY_META', 'SETTERS_BY_TYPE', 'SMALLINT', 'SQLXML', 'STRING', 'TEXT', 'TIME', 'TIMESTAMP', 'TIMESTAMP_WITH_TIMEZONE', 'TIME_WITH_TIMEZONE', 'TINYINT', 'Time', 'TimeFromTicks', 'Timestamp', 'TimestampFromTicks', 'URL', 'VARBINARY', 'VARCHAR', 'Warning', 'apilevel', 'connect', 'paramstyle', 'threadsafety']
apilevel = ...
threadsafety = ...
paramstyle = ...
_SQLException = ...
_SQLTimeoutException = ...
_registry = ...
_types = ...
class JDBCType:
    def __init__(self, name, code=..., getter=..., setter=...) -> None:
        """ (internal) Create a new JDBC type. """
        ...
    
    def get(self, rs, column, st): # -> Any:
        """ A method to retrieve a specific JDBC type.

        To use a getter add the fetch method to the JDBC type matching the
        column type to be pulled.  For example, to set the getter for FLOAT to
        use the OBJECT getter, use  ``cx.getter[FLOAT] = OBJECT.get``.

        Not all getters are available on all database drivers.  Consult the
        database driver documentation for details.
        """
        ...
    
    def set(self, ps, column, value): # -> Any:
        """ A method used to set a parameter to a query.

        To use a setter place the set method in the setter dict corresponding.
        For example, if the database supports Blob types, the default handler
        for BLOB can be changed from OBJECT to BLOB with
        ``cx.setter[BLOB] = BLOB.set``.

        Not all setters are available on all database drivers.  Consult the
        database driver documentation for details.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class _JDBCTypePrimitive(JDBCType):
    def get(self, rs, column, st): # -> Any | Literal[0] | None:
        ...
    


ARRAY = ...
BIGINT = ...
BIT = ...
BLOB = ...
BOOLEAN = ...
CHAR = ...
CLOB = ...
DATE = ...
DOUBLE = ...
INTEGER = ...
OBJECT = ...
LONGNVARCHAR = ...
LONGVARBINARY = ...
LONGVARCHAR = ...
NCHAR = ...
NCLOB = ...
NULL = ...
NUMERIC = ...
NVARCHAR = ...
OTHER = ...
REAL = ...
REF = ...
ROWID = ...
RESULTSET = ...
SMALLINT = ...
SQLXML = ...
TIME = ...
TIME_WITH_TIMEZONE = ...
TIMESTAMP = ...
TIMESTAMP_WITH_TIMEZONE = ...
TINYINT = ...
VARBINARY = ...
VARCHAR = ...
STRING = ...
TEXT = ...
BINARY = ...
NUMBER = ...
FLOAT = ...
DECIMAL = ...
DATETIME = ...
ASCII_STREAM = ...
BINARY_STREAM = ...
CHARACTER_STREAM = ...
NCHARACTER_STREAM = ...
URL = ...
_default_map = ...
_default_setters = ...
_default_converters = ...
_default_adapters = ...
def SETTERS_BY_META(cx, meta, col, ptype):
    """ Option for setters to use the metadata of the parameters.

    On some databases this option is useless as they do not track parameter
    types.  This method can be cached for faster performance when the are lots
    of parameters.  Usually types can only be determined accurately on inserts
    into defined columns.
    """
    ...

def SETTERS_BY_TYPE(cx, meta, col, ptype):
    """ Option for setters to use the type of the object passed.

    This option looks at the type of the parameter being passed
    from Python after adapters have been applied to determine the
    best setter.
    """
    ...

def GETTERS_BY_TYPE(cx, meta, idx):
    """ Option for getters to determine column type by the JDBC type.

    This option is the default option that uses the type code supplied in
    the meta data.  On some databases it is better to use the name.
    If the type code is OTHER, it will attempt to find a type by name.
    New types can be created with JDBCType for database specific types.
    """
    ...

def GETTERS_BY_NAME(cx, meta, idx):
    """ Option for getters to determine column type by the column name.

    This option uses the column name to select the type.  It looks up
    the column type name, converts it to uppercase, and then searches
    for a matching type.  It falls back to the type code meta information if
    the type name cannot be found in the registry.  New types can be created
    using JDBCType for database specific types such as ``JSON``.
    """
    ...

class Warning(Exception):
    """Exception raised for important warnings like data truncations while
    inserting, etc. """
    ...


class Error(Exception):
    """Exception that is the base class of all other error exceptions. You can use
    this to catch all errors with one single except statement. Warnings are not
    considered errors and thus should not use this class as base.
    """
    ...


class InterfaceError(Error, TypeError):
    """ Exception raised for errors that are related to the database interface
    rather than the database itself."""
    ...


class DatabaseError(Error):
    """ Exception raised for errors that are related to the database."""
    ...


class DataError(DatabaseError):
    """ Exception raised for errors that are due to problems with the processed
    data like division by zero, numeric value out of range, etc."""
    ...


class OperationalError(DatabaseError):
    """ Exception raised for errors that are related to the database's operation
    and not necessarily under the control of the programmer, e.g. an unexpected
    disconnect occurs, the data source name is not found, a transaction could not
    be processed, a memory allocation error occurred during processing, etc."""
    ...


class IntegrityError(DatabaseError):
    """ Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails."""
    ...


class InternalError(DatabaseError):
    """ Exception raised when the database encounters an internal error, e.g. the
    cursor is not valid anymore, the transaction is out of sync, etc."""
    ...


class ProgrammingError(DatabaseError):
    """ Exception raised for programming errors, e.g. table not found or already
    exists, syntax error in the SQL statement, wrong number of parameters
    specified, etc."""
    ...


class NotSupportedError(DatabaseError):
    """ Exception raised in case a method or database API was used which is not
    supported by the database, e.g. requesting a .rollback() on a connection that
    does not support transaction or has transactions turned off.
    """
    ...


class _UnsupportedTypeError(InterfaceError, TypeError):
    ...


_default = ...
def connect(dsn, *, driver=..., driver_args=..., adapters=..., converters=..., getters=..., setters=..., **kwargs): # -> Connection:
    """ Create a connection to a database.

    Arguments to the driver depend on the database type.

    Args:
       dsn (str): The database connection string for JDBC.
       driver (str, optional): A JDBC driver to load.
       driver_args: Arguments to the driver.  This may either be a dict,
          java.util.Properties.  If not supplied, kwargs are used as the
          parameters for the JDBC connection.
       *kwargs: Arguments to the driver if not supplied as
          driver_args.

    Raises:
       Error if the connection cannot be established.

    Returns:
       A new connection if successful.
    """
    ...

class Connection:
    """ Connection provides access to a JDBC database.

    Connections are managed and can be used as part of a Python 'with' statement.
    Connections close automatically when they are garbage collected, at the
    end of a with statement scope, or when manually closed.  Once a connection
    is closed all operations using the database will raise an Error.
    """
    Error = Error
    Warning = Warning
    InterfaceError = InterfaceError
    DatabaseError = DatabaseError
    InternalError = InternalError
    OperationalError = OperationalError
    ProgrammingError = ProgrammingError
    IntegrityError = IntegrityError
    DataError = DataError
    NotSupportedError = NotSupportedError
    def __init__(self, jconnection, adapters, converters, setters, getters) -> None:
        ...
    
    @property
    def adapters(self): # -> dict[Any, Any] | Mapping[Any, Any]:
        """ Adapters are used to convert Python types into JDBC types.

        Adaptors are stored in a mapping from incoming type to an adapter
        function.  Adapters set on a connection apply only to that connection.
        Adapters can be overriden when calling the ``.execute*()`` method.

        Adapters can also be set on the JDBC types directly.
        """
        ...
    
    @adapters.setter
    def adapters(self, v): # -> None:
        ...
    
    @property
    def converters(self): # -> dict[Any, Any] | Mapping[Any, Any]:
        """ Converters are applied when retrieving a JDBC type from the database.

        """
        ...
    
    @converters.setter
    def converters(self, v): # -> None:
        ...
    
    @property
    def getters(self): # -> Any:
        """ Getters are used to retrieve JDBC types from the database following
        a ``.fetch*()``.

        Getters should be a function taking (connection, meta, col) -> JDBCTYPE
        """
        ...
    
    @getters.setter
    def getters(self, v): # -> None:
        ...
    
    @property
    def setters(self): # -> Any:
        """ Setters are used to set parameters to ``.execute*()`` methods.

        Setters should be a function taking (connection, meta, col, type) -> JDBCTYPE
        """
        ...
    
    @setters.setter
    def setters(self, v): # -> None:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exception_type, exception_value, traceback): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def close(self): # -> None:
        """ Close the connection immediately (rather than whenever .__del__() is called).

        The connection will be unusable from this point forward; an Error (or
        subclass) exception will be raised if any operation is attempted with
        the connection. The same applies to all cursor objects trying to use
        the connection. Note that closing a connection without committing the
        changes first will cause an implicit rollback to be performed.  """
        ...
    
    def commit(self): # -> None:
        """Commit any pending transaction to the database.

        Calling commit on a connection that does not support the operation
        will raise NotSupportedError.
        """
        ...
    
    def rollback(self): # -> None:
        """Rollback the transaction.

        This method is optional since not all databases provide transaction
        support.  Calling rollback on a connection that does not support it 
        will raise NotSupportedError.

        In case a database does provide transactions this method causes the
        database to roll back to the start of any pending transaction. Closing
        a connection without committing the changes first will cause an
        implicit rollback to be performed.
        """
        ...
    
    def cursor(self): # -> Cursor:
        """ Return a new Cursor Object using the connection. """
        ...
    
    @property
    def connection(self): # -> Any:
        """ Get the JDBC connection that is backing this Python
        Connection object.

        This can be used to retrieve additional metadata and other features
        that are outside of the scope of the DBAPI driver.
        """
        ...
    
    @property
    def autocommit(self):
        """ bool: Property controlling autocommit behavior.

        By default connects are not autocommit.  Setting autocommit
        will result in commit and rollback producing a ProgrammingError.
        """
        ...
    
    @autocommit.setter
    def autocommit(self, enabled): # -> None:
        ...
    
    @property
    def typeinfo(self): # -> dict[Any, Any]:
        """ list: The list of types that are supported by this driver.

        This is useful to find out the capabilities of the driver.
        """
        ...
    


class Cursor:
    """ Cursors are used to execute queries and retrieve results.

    Part PreparedStatement, part ResultSet,  Cursors are a mixture of
    both.  The native resultSet can be accessed with ``resultSet``.

    Cursors are managed and can be as part of a Python with statement.
    Cursors close automatically when they are garbage collected, at the
    end of a with statement scope, or when manually closed.  Once a cursor
    is closed all operations using the database will raise an Error.
    """
    def __init__(self, connection) -> None:
        ...
    
    @property
    def resultSet(self): # -> None:
        """ Get the Java result set if available.

        The object will be closed on the next call to ``.execute*()``.
        """
        ...
    
    @property
    def parameters(self): # -> list[Any]:
        """ (extension) Parameters is a read-only attribute. It is a sequence
        of 6-item sequences.

        Each of these sequences contains information describing one result
        column:

        - type_name
        - jdbc_type
        - parameter_mode (1=in, 2=in/out, 4=out)
        - precision
        - scale
        - null_ok

        This can only be used after execute or callproc.
        """
        ...
    
    @property
    def description(self): # -> list[Any] | None:
        """ Description is a read-only attribute. It is a sequence of 7-item
        sequences.

        Each of these sequences contains information describing one result
        column:

        - name
        - type_code
        - display_size
        - internal_size
        - precision
        - scale
        - null_ok

        This can only be used if the last query produced a result set.
        """
        ...
    
    @property
    def rowcount(self): # -> int:
        """ This read-only attribute specifies the number of rows that the last
        .execute*() affected (for DML statements like UPDATE or INSERT).

        The attribute is -1 in case no .execute*() has been performed on the
        cursor or the rowcount of the last operation cannot be determined by
        the interface.  JDBC does not support getting the number of rows
        returned from SELECT, so for most drivers rowcount will be -1 after a
        SELECT statement.
        """
        ...
    
    def close(self): # -> None:
        """ Close the cursor now (rather than whenever __del__ is called).

        The cursor will be unusable from this point forward; an Error (or
        subclass) exception will be raised if any operation is attempted with
        the cursor.
        """
        ...
    
    def callproc(self, procname, parameters=..., *, types=...):
        """ Call a stored procedure.

        (Not all JDBC drivers support this method)

        Call a stored database procedure with the given name. The sequence of
        parameters must contain one entry for each argument that the procedure
        expects. The result of the call is returned as modified copy of the
        input sequence. Input parameters are left untouched, output and
        input/output parameters replaced with possibly new values.

        For type output and input/output arguments, it is best to use
        types keyword argument to select the appropriate getters for the 
        returned arguments.  Converters are applied to output parameters.

        The procedure may also provide a result set as output. This must then
        be made available through the standard .fetch*() methods. 
        """
        ...
    
    def execute(self, operation, parameters=..., *, types=..., keys=...): # -> Self:
        """
        Prepare and execute a database operation (query or command).

        Parameters may be provided as sequence and will be bound to variables
        in the operation. Variables are specified in a qmark notation.  JDBC
        does not support mapping style parameters.

        After executing a statement, the rowcount will be updated.  If the
        statement has no result set then the rowcount will be -1.  A statement
        can produce multiple result sets.  Use ``.nextset()`` to traverse the
        sets.

        Parameters:
           operation (str): A statement to be executed.
           parameters (list, optional): A list of parameters for the statement.
              The number of parameters must match the number required by the
              statement or an Error will be raised.
           keys (bool, optional): Specify if the keys should be available to 
              retrieve. (Default False) 

        Returns:
           This cursor.
        """
        ...
    
    def executemany(self, operation, seq_of_parameters, *, types=..., keys=...): # -> Self:
        """
        Prepare a database operation (query or command) and then execute it
        against all parameter sequences or mappings found in the sequence
        seq_of_parameters.

        Modules are free to implement this method using multiple calls to the
        .execute() method or by using array operations to have the database
        process the sequence as a whole in one call.

        Use of this method for an operation which produces one or more result
        sets constitutes undefined behavior, and the implementation is
        permitted (but not required) to raise an exception when it detects that
        a result set has been created by an invocation of the operation.

        The same comments as for .execute() also apply accordingly to this
        method.

        Args:
           operation (str): A statement to be executed.
           seq_of_parameters (list, optional): A list of lists of parameters
               for the statement.  The number of parameters must match the number
               required by the statement or an Error will be raised.
           keys (bool, optional): Specify if the keys should be available to 
              retrieve. (Default False) For drivers that do not support
              batch updates only the last key will be returned.

        Returns:
           This cursor.
        """
        ...
    
    def fetchone(self, *, types=..., converters=...): # -> list[Any] | None:
        """
        Fetch the next row of a query result set, returning a single
        sequence, or None when no more data is available.

        An Error (or subclass) exception is raised if the previous call to
        .execute*() did not produce any result set or no call was issued yet.
        """
        ...
    
    def fetchmany(self, size=..., *, types=..., converters=...): # -> list[Any]:
        """ Fetch multiple results.

        Fetch the next set of rows of a query result, returning a sequence of
        sequences (e.g. a list of tuples). An empty sequence is returned when
        no more rows are available.

        The number of rows to fetch per call is specified by the parameter. If it
        is not given, the cursor's arraysize determines the number of rows to be
        fetched. The method should try to fetch as many rows as indicated by the
        size parameter. If this is not possible due to the specified number of rows
        not being available, fewer rows may be returned.

        An Error (or subclass) exception is raised if the previous call to
        ``.execute*()`` did not produce any result set or no call was issued yet.

        Note there are performance considerations involved with the size parameter.
        For optimal performance, it is usually best to use the .arraysize
        attribute. If the size parameter is used, then it is best for it to retain
        the same value from one ``.fetchmany()`` call to the next.
        """
        ...
    
    def fetchall(self, *, types=..., converters=...): # -> list[Any]:
        """ Fetch all (remaining) rows of a query result, returning them as
        a sequence of sequences (e.g. a list of tuples). Note that the cursor's
        arraysize attribute can affect the performance of this operation.

        An Error (or subclass) exception is raised if the previous call to
        ``.execute*()`` did not produce any result set or no call was issued yet.
        """
        ...
    
    def __iter__(self): # -> Generator[list[Any], Any, None]:
        """ (extension) Iterate through a cursor one record at a time.
        """
        ...
    
    def nextset(self): # -> Literal[True] | None:
        """ Get the next result set in this cursor.

        Not all databases support multiple result sets.

        This method will make the cursor skip to the next available set, discarding
        any remaining rows from the current set.

        If there are no more sets, the method returns None. Otherwise, it returns a
        true value and subsequent calls to the ``.fetch*()`` methods will return rows
        from the next result set.

        An Error (or subclass) exception is raised if the previous call to
        ``.execute*()`` did not produce any result set or no call was issued yet.
        """
        ...
    
    @property
    def arraysize(self): # -> int:
        """
        Specify the number of rows to fetch with ``.fetchmany()``.

        This read/write attribute specifies the number of rows to fetch
        at a time with ``.fetchmany()``. It defaults to 1 meaning to fetch a single row
        at a time.
        """
        ...
    
    @arraysize.setter
    def arraysize(self, sz): # -> None:
        ...
    
    @property
    def lastrowid(self): # -> list[Any] | None:
        """ Get the id of the last row inserted.

        This is not supported on all JDBC drivers. The ``.execute*()`` must have
        been executed with keys set to True.

        Returns:
           None if there is no rowid, the rowid if only one row was inserted,
           or a list of row ids if multiple rows were inserted.
        """
        ...
    
    def setinputsizes(self, sizes): # -> None:
        """ This can be used before a call to .execute*() to
        predefine memory areas for the operation's parameters.

        sizes is specified as a sequence — one item for each input parameter. The
        item should be a Type Object that corresponds to the input that will be
        used, or it should be an integer specifying the maximum length of a string
        parameter. If the item is None, then no predefined memory area will be
        reserved for that column (this is useful to avoid predefined areas for
        large inputs).

        This method would be used before the .execute*() method is invoked.

        (not implemented)
        """
        ...
    
    def setoutputsize(self, size, column=...): # -> None:
        """
        Set a column buffer size for fetches of large columns (e.g. LONGs, BLOBs, etc.).

        The column is specified as an index into the result sequence. Not
        specifying the column will set the default size for all large columns
        in the cursor.

        (not implemented)
        """
        ...
    
    def __del__(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exception_type, exception_value, traceback): # -> None:
        ...
    


def Date(year, month, day):
    """ This function constructs an object holding a date value. """
    ...

def Time(hour, minute, second):
    """ This function constructs an object holding a time value. """
    ...

def Timestamp(year, month, day, hour, minute, second, nano=...):
    """ This function constructs an object holding a timestamp value. """
    ...

def DateFromTicks(ticks):
    """
    This function constructs an object holding a date value from the given
    ticks value (number of seconds since the epoch; see the documentation of
    the standard Python time module for details).
    """
    ...

def TimeFromTicks(ticks):
    """

    This function constructs an object holding a time value from the given
    ticks value (number of seconds since the epoch; see the documentation of
    the standard Python time module for details).
    """
    ...

def TimestampFromTicks(ticks):
    """
    This function constructs an object holding a timestamp value from the
    given ticks value (number of seconds since the epoch; see the documentation
    of the standard Python time module for details).
    """
    ...

def Binary(data):
    """
    This function constructs an object capable of holding a binary (long)
    string value.
    """
    ...

_accepted = ...
