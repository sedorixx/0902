"""
This type stub file was generated by pyright.
"""

import _jpype

__all__ = ['JImplementationFor', 'JConversion']
_jcopymembers = ...
def JConversion(cls, exact=..., instanceof=..., attribute=..., excludes=...): # -> Callable[..., Any | None]:
    """ Decorator to define a method as a converted a Java type.

    Whenever a method resolution is called the JPype internal rules
    are applied, but this may be insufficient.  If only a
    single method requires modification then a class customizer can
    be applied.  But if many interfaces require the same conversion
    than a user conversion may be a better option.

    To add a user conversion define a method which take the requested
    Java type as the first argument, the target object to be converted
    as the second argument and returns a Java object or Java proxy that
    matches the required type.  If the type is not a Java type then
    a TypeError will be raised.  This method is only evaluated
    after the match has been determine prior to calling.

    Care should be used when defining a user conversion. If example
    if one has an interface that requires a specific class and you
    want it to take a Python string, then a user conversion can
    do that.  On the other hand, if you define a generic converter
    of any Python object to a Java string, then every interface
    will attempt to call the conversion method whenever a Java string
    is being matched, which can cause many methods to potentially
    become ambiguous.

    Conversion are not inherited. If the same converter needs to
    apply to multiple types, then multiple decorators can
    be applied to the same method.

    Args:
      cls(str, JClass): The class that will be produced by this
        conversion.
      exact(type): This conversion applies only to objects that have
        a type exactly equal to the argument.
      instanceof(type or protocol): This conversion applies to 
        any object that passes isinstance(obj, type).
      attribute(str): This conversion applies to any object that has
        passes hasattr(obj, arg). (deprecated)
      excludes(type): Prevents a conversion for a specified type.
        Can be used to prevent a specific type from being converted.
        For example, to prevent maps or strings from passing 
        a check for Sequence.  Exclusions are applied before all 
        other user specificied conversions.
    """
    ...

def JImplementationFor(clsname, base=...): # -> Callable[..., Any]:
    """ Decorator to define an implementation for a class.

    Applies to a class which will serve as a prototype as for the Java class
    wrapper.  If it is registered as a base class, then the class must
    derive from JObject.  Otherwise, the methods are copied from
    the prototype to the Java class wrapper.

    The method ``__jclass_init__(cls)`` will be called with the constructed
    class as the argument.  This call is used to set methods for all classes
    that derive from the specified class.  Use ``jclass._customize()`` to
    alter the class methods.

    Using the prototype class as a base class is used mainly to support
    classes which must be derived from a Python type by design.  Use
    of a base class will produce a RuntimeError if the class has already
    been created.

    For non-base class customizers, the customizer will be applied
    retroactively if the class is already created.  Conflicts are
    resolved by the last customizer applied.

    Args:
      clsname (str): name of java class.
      base (bool, optional): if True this will be a base class.
        Default is False.

    """
    ...

class JClassHints(_jpype._JClassHints):
    """ ClassHints holds class customizers and conversions.

    These items can be defined before the JVM is created.
    """
    def __init__(self) -> None:
        ...
    
    def registerClassBase(self, base): # -> None:
        """ (internal) Add an implementation for a class

        Use @JImplementationFor(cls, base=True) to access this.

        """
        ...
    
    def registerClassImplementation(self, classname, proto): # -> None:
        """ (internal) Add an implementation for a class

        Use @JImplementationFor(cls) to access this.
        """
        ...
    
    def applyCustomizers(self, name, bases, members): # -> None:
        """ (internal) Called by JClass and JArray to customize a newly created class."""
        ...
    
    def applyInitializer(self, cls): # -> None:
        """ (internal) Called after the class is created to apply any customizations
        required by inherited parents.
        """
        ...
    


def getClassHints(name): # -> JClassHints:
    ...

